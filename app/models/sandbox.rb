# == Schema Information
#
# Table name: sandboxes
#
#  id         :integer          not null, primary key
#  created_at :datetime         not null
#  updated_at :datetime         not null
#

class Sandbox < ActiveRecord::Base
  require 'timeout'

  ALLOWED_METHODS = [
    :+,
    :-,
    :/,
    :%,
    :*,
    :>,
    :<,
    :>=,
    :<=,
    :==,
    :**,
    :[],
    :&,
    :to_s,
    :scan,
    :length,
    :size,
    :while,
    :do,
    :times,
    :end,
    :!,
    :=~,
    :if,
    :else,
    :elsif,
    :zero?,
    :unless,
    :return,
    :each,
    :map,
    :select,
    :reject,
    :collect,
    :to_f,
    :to_i,
    :acos,
    :acosh,
    :asin,
    :asinh,
    :atan,
    :atan2,
    :atanh,
    :cbrt,
    :cos,
    :cosh,
    :erf,
    :erfc,
    :exp,
    :frexp,
    :gamma,
    :hypot,
    :ldexp,
    :lgamma,
    :log,
    :log10,
    :log2,
    :sin,
    :sinh,
    :sqrt,
    :tan,
    :tanh,
    :floor,
    :include,
    :reduce,
    :all?,
    :any?,
    :chunk,
    :collect,
    :collect_concat,
    :count,
    :cycle,
    :detect,
    :drop,
    :drop_while,
    :each_cons,
    :each_entry,
    :each_slice,
    :each_with_index,
    :each_with_object,
    :entries,
    :find,
    :find_all,
    :find_index,
    :first,
    :flat_map,
    :grep,
    :group_by,
    :include?,
    :inject,
    :lazy,
    :map,
    :max,
    :max_by,
    :member?,
    :min,
    :min_by,
    :minmax,
    :minmax_by,
    :none?,
    :one?,
    :partition,
    :reduce,
    :reject,
    :reverse_each,
    :select,
    :slice_after,
    :slice_before,
    :slice_when,
    :sort,
    :sort_by,
    :take,
    :take_while,
    :to_a,
    :to_h,
    :zip,
    :split,
    :join,
    :replace,
    :delete_if,
    :map!,
    :%,
    :*,
    :+,
    :<<,
    :<=>,
    :==,
    :===,
    :=~,
    :[],
    :[]=,
    :ascii_only?,
    :b,
    :bytes,
    :bytesize,
    :byteslice,
    :capitalize,
    :capitalize!,
    :casecmp,
    :center,
    :chars,
    :chomp,
    :chomp!,
    :chop,
    :chop!,
    :chr,
    :clear,
    :codepoints,
    :concat,
    :count,
    :crypt,
    :delete,
    :delete!,
    :downcase,
    :downcase!,
    :dump,
    :each_byte,
    :each_char,
    :each_codepoint,
    :each_line,
    :empty?,
    :encode,
    :encode!,
    :encoding,
    :end_with?,
    :eql?,
    :force_encoding,
    :getbyte,
    :gsub,
    :gsub!,
    :hash,
    :hex,
    :include?,
    :index,
    :initialize_copy,
    :insert,
    :inspect,
    :intern,
    :length,
    :lines,
    :ljust,
    :lstrip,
    :lstrip!,
    :match,
    :next,
    :next!,
    :oct,
    :ord,
    :partition,
    :prepend,
    :replace,
    :reverse,
    :reverse!,
    :rindex,
    :rjust,
    :rpartition,
    :rstrip,
    :rstrip!,
    :scan,
    :scrub,
    :scrub!,
    :setbyte,
    :size,
    :slice,
    :slice!,
    :split,
    :squeeze,
    :squeeze!,
    :start_with?,
    :strip,
    :strip!,
    :sub,
    :sub!,
    :succ,
    :succ!,
    :sum,
    :swapcase,
    :swapcase!,
    :to_c,
    :to_f,
    :to_i,
    :to_r,
    :to_s,
    :to_str,
    :to_sym,
    :tr,
    :tr!,
    :tr_s,
    :tr_s!,
    :unpack,
    :upcase,
    :upcase!,
    :upto,
    :valid_encoding?,
    :&,
    :*,
    :+,
    :-,
    :<<,
    :<=>,
    :==,
    :[],
    :[]=,
    :any?,
    :assoc,
    :at,
    :bsearch,
    :clear,
    :collect,
    :collect!,
    :combination,
    :compact,
    :compact!,
    :concat,
    :count,
    :cycle,
    :delete,
    :delete_at,
    :delete_if,
    :drop,
    :drop_while,
    :each,
    :each_index,
    :empty?,
    :eql?,
    :fetch,
    :fill,
    :find_index,
    :first,
    :flatten,
    :flatten!,
    :frozen?,
    :hash,
    :include?,
    :index,
    :initialize_copy,
    :insert,
    :inspect,
    :join,
    :keep_if,
    :last,
    :length,
    :map,
    :map!,
    :pack,
    :permutation,
    :pop,
    :product,
    :push,
    :rassoc,
    :reject,
    :reject!,
    :repeated_combination,
    :repeated_permutation,
    :replace,
    :reverse,
    :reverse!,
    :reverse_each,
    :rindex,
    :rotate,
    :rotate!,
    :sample,
    :select,
    :select!,
    :shift,
    :shuffle,
    :shuffle!,
    :size,
    :slice,
    :slice!,
    :sort,
    :sort!,
    :sort_by!,
    :take,
    :take_while,
    :to_a,
    :to_ary,
    :to_h,
    :to_s,
    :transpose,
    :uniq,
    :uniq!,
    :unshift,
    :values_at,
    :zip,
    :|,
    :==,
    :[],
    :[]=,
    :any?,
    :assoc,
    :clear,
    :compare_by_identity,
    :compare_by_identity?,
    :default,
    :default=,
    :default_proc,
    :default_proc=,
    :delete,
    :delete_if,
    :each,
    :each_key,
    :each_pair,
    :each_value,
    :empty?,
    :eql?,
    :fetch,
    :flatten,
    :has_key?,
    :has_value?,
    :hash,
    :include?,
    :inspect,
    :invert,
    :keep_if,
    :key,
    :key?,
    :keys,
    :length,
    :member?,
    :merge,
    :merge!,
    :rassoc,
    :rehash,
    :reject,
    :reject!,
    :replace,
    :select,
    :select!,
    :shift,
    :size,
    :store,
    :to_a,
    :to_h,
    :to_hash,
    :to_s,
    :update,
    :value?,
    :values,
    :values_at,
    :is_a?,
    :even?,
    :odd?,
    :new,
    :singleton_method_added
  ]

  def self.runTests(solutionString, testString)
    tests = self.cleanTestString(testString)
    result = tests.map do |t|
      self.runInSandbox(solutionString + "\n" + t)
    end
  end

  def self.cleanTestString(tests)
    tests.split("\n").map { |el| el.strip() }.reject { |el| el.empty? }
  end

  def self.runInSandbox(string)
    string = "include Math\n" + string # lets users use the Math module
    s = Shikashi::Sandbox.new
    priv = Shikashi::Privileges.new
    priv.allow_const_read "Math" # lets users use the Math module
    ALLOWED_METHODS.each { |method| priv.allow_method(method) }
    meth = "!=".to_sym  # special case
    priv.allow_method(meth)
    priv.allow_class_definitions
    priv.allow_singleton_methods

    begin
      result = Timeout::timeout(3) {
        s.run :code => string, :privileges => priv, :timeout => 3
      }
    rescue SecurityError => e
      return {error: "SecurityError", message: e.message}
    rescue ArgumentError => e
      return {error: "ArgumentError", message: e.message}
    rescue IndexError => e
      return {error: "IndexError", message: e.message}
    rescue NameError => e
      return {error: "NameError", message: e.message}
    rescue RegexpError => e
      return {error: "RegexpError", message: e.message}
    rescue TypeError => e
      return {error: "TypeError", message: e.message}
    rescue ZeroDivisionError => e
      return {error: "ZeroDivisionError", message: e.message}
    rescue SyntaxError => e
      return {error: "SyntaxError", message: e.message}
    rescue LocalJumpError => e
      return {error: "LocalJumpError", message: e.message}
    rescue Shikashi::Timeout::Error => e
      return {error: "TimeoutError", message: "execution time limit exceeded."}
    rescue Timeout::Error => e
      return {error: "TimeoutError", message: e.message}
    rescue Timeout::ExitException => e
      return {error: "TimeoutError", message: e.message}
    end

    return {success: result}
  end
end
